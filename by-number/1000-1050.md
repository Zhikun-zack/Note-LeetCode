# 1000-1050

* [x] [1024 Video Stitching](1000-1050.md#1024-video-stitching-m)
* [ ] 1025
* [ ] 1026
* [x] [1029 Two City Scheduling](1000-1050.md#1029-two-city-scheduling)





## 1024 Video Stitching M

### Description



You are given a series of video clips from a sporting event that lasted `time` seconds. These video clips can be overlapping with each other and have varying lengths.

Each video clip is described by an array `clips` where `clips[i] = [starti, endi]` indicates that the ith clip started at `starti` and ended at `endi`.

We can cut these clips into segments freely.

* For example, a clip `[0, 7]` can be cut into segments `[0, 1] + [1, 3] + [3, 7]`.

Return _the minimum number of clips needed so that we can cut the clips into segments that cover the entire sporting event_ `[0, time]`. If the task is impossible, return `-1`.

&#x20;

**Example 1:**

```
Input: clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], time = 10
Output: 3
Explanation: We take the clips [0,2], [8,10], [1,9]; a total of 3 clips.
Then, we can reconstruct the sporting event as follows:
We cut [1,9] into segments [1,2] + [2,8] + [8,9].
Now we have segments [0,2] + [2,8] + [8,10] which cover the sporting event [0, 10].
```

**Example 2:**

```
Input: clips = [[0,1],[1,2]], time = 5
Output: -1
Explanation: We cannot cover [0,5] with only [0,1] and [1,2].
```

**Example 3:**

```
Input: clips = [[0,1],[6,8],[0,2],[5,6],[0,4],[0,3],[6,7],[1,3],[4,7],[1,4],[2,5],[2,6],[3,4],[4,5],[5,7],[6,9]], time = 9
Output: 3
Explanation: We can take clips [0,4], [4,7], and [6,9].
```

&#x20;

**Constraints:**

* `1 <= clips.length <= 100`
* `0 <= starti <= endi <= 100`
* `1 <= time <= 100`

### Solution

```
// Some code
class Solution:
    def videoStitching(self, clips: List[List[int]], time: int) -> int:
        farthest = [0]*time
        last = end = res = 0
        
        for a, b in clips:
            if a < time:
                farthest[a] = max(farthest[a], b)
            
        for i in range(time):
            last = max(farthest[i], last)
            if i == last:
                return -1
            if i == end:
                end = last
                res += 1
        return res
```



## 1029 Two City Scheduling M

### Description



A company is planning to interview `2n` people. Given the array `costs` where `costs[i] = [aCosti, bCosti]`, the cost of flying the `ith` person to city `a` is `aCosti`, and the cost of flying the `ith` person to city `b` is `bCosti`.

Return _the minimum cost to fly every person to a city_ such that exactly `n` people arrive in each city.

&#x20;

**Example 1:**

```
Input: costs = [[10,20],[30,200],[400,50],[30,20]]
Output: 110
Explanation: 
The first person goes to city A for a cost of 10.
The second person goes to city A for a cost of 30.
The third person goes to city B for a cost of 50.
The fourth person goes to city B for a cost of 20.

The total minimum cost is 10 + 30 + 50 + 20 = 110 to have half the people interviewing in each city.
```

**Example 2:**

```
Input: costs = [[259,770],[448,54],[926,667],[184,139],[840,118],[577,469]]
Output: 1859
```

**Example 3:**

```
Input: costs = [[515,563],[451,713],[537,709],[343,819],[855,779],[457,60],[650,359],[631,42]]
Output: 3086
```

&#x20;

**Constraints:**

* `2 * n == costs.length`
* `2 <= costs.length <= 100`
* `costs.length` is even.
* `1 <= aCosti, bCosti <= 1000`

### Solution

Sort based on value of price A - price B

```
// 
class Solution:
    def twoCitySchedCost(self, costs: List[List[int]]) -> int:
        # Sort by priceA - priceB
        # Larger means price B is cheaper, smaller is A is better
        costs.sort(key = lambda x: x[0] - x[1])
        
        res = 0
        n = len(costs)
        for i in range(n//2):
            res += costs[i][0] + costs[i + n//2][1]
        return res
```
