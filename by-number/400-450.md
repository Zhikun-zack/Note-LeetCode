# 400-450

* [x] [406 Queue Reconstruction by Height](400-450.md#406-queue-reconstruction-by-height)
* [ ] 407
* [x] 408 Valid Word Abbreviation
*
* [x] 438 Find All Anagrams in a String



## 406 Queue Reconstruction by Height

### Description



You are given an array of people, `people`, which are the attributes of some people in a queue (not necessarily in order). Each `people[i] = [hi, ki]` represents the `ith` person of height `hi` with **exactly** `ki` other people in front who have a height greater than or equal to `hi`.

Reconstruct and return _the queue that is represented by the input array_ `people`. The returned queue should be formatted as an array `queue`, where `queue[j] = [hj, kj]` is the attributes of the `jth` person in the queue (`queue[0]` is the person at the front of the queue).

&#x20;

**Example 1:**

```
Input: people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
Output: [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
Explanation:
Person 0 has height 5 with no other people taller or the same height in front.
Person 1 has height 7 with no other people taller or the same height in front.
Person 2 has height 5 with two persons taller or the same height in front, which is person 0 and 1.
Person 3 has height 6 with one person taller or the same height in front, which is person 1.
Person 4 has height 4 with four people taller or the same height in front, which are people 0, 1, 2, and 3.
Person 5 has height 7 with one person taller or the same height in front, which is person 1.
Hence [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] is the reconstructed queue.
```

**Example 2:**

```
Input: people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]
Output: [[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]
```

&#x20;

**Constraints:**

* `1 <= people.length <= 2000`
* `0 <= hi <= 106`
* `0 <= ki < people.length`
* It is guaranteed that the queue can be reconstructed.

### Solution

* All the people who is shorter than ith people will not be counted in ki value
* But the people who is higher than ith people will affect the ki value
* So we first insert higher people and then insert the shorter guy later
* Sort the list based on height first and then the position
* Insert the people into the ki position, higher first and shorter later&#x20;

```
// Sort
class Solution:
    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:
        # sort list based on height first and then order 
        people.sort(key = lambda x: (-x[0], x[1]))
        # create a queue to store the result
        res = []
        
        for i in people:
            res.insert(i[1], i)
        return res
```

## 408 Valid Word Abbreviation E

### Description



A string can be **abbreviated** by replacing any number of **non-adjacent**, **non-empty** substrings with their lengths. The lengths **should not** have leading zeros.

For example, a string such as `"substitution"` could be abbreviated as (but not limited to):

* `"s10n"` (`"s ubstitutio n"`)
* `"sub4u4"` (`"sub stit u tion"`)
* `"12"` (`"substitution"`)
* `"su3i1u2on"` (`"su bst i t u ti on"`)
* `"substitution"` (no substrings replaced)

The following are **not valid** abbreviations:

* `"s55n"` (`"s ubsti tutio n"`, the replaced substrings are adjacent)
* `"s010n"` (has leading zeros)
* `"s0ubstitution"` (replaces an empty substring)

Given a string `word` and an abbreviation `abbr`, return _whether the string **matches** the given abbreviation_.

A **substring** is a contiguous **non-empty** sequence of characters within a string.

&#x20;

**Example 1:**

```
Input: word = "internationalization", abbr = "i12iz4n"
Output: true
Explanation: The word "internationalization" can be abbreviated as "i12iz4n" ("i nternational iz atio n").
```

**Example 2:**

```
Input: word = "apple", abbr = "a2e"
Output: false
Explanation: The word "apple" cannot be abbreviated as "a2e".
```

&#x20;

**Constraints:**

* `1 <= word.length <= 20`
* `word` consists of only lowercase English letters.
* `1 <= abbr.length <= 10`
* `abbr` consists of lowercase English letters and digits.
* All the integers in `abbr` will fit in a 32-bit integer.

### Solution

1. Two pointers
2. Many situations:
   1. is not digit: if two value not equal, return false
   2. is not digit: else go next
   3. is digit: if first digit is 0 return false
   4. is digit: if not 0, get the number by while loop

```
// O(N) O(1)
class Solution:
    def validWordAbbreviation(self, word: str, abbr: str) -> bool:
        p1 = p2 = 0
        while p1 < len(word) and p2 < len(abbr):
            if abbr[p2].isdigit():
                if abbr[p2] == '0': # leading zeros are invalid
                    return False
                shift = 0
                while p2 < len(abbr) and abbr[p2].isdigit():
                    shift = (shift*10)+int(abbr[p2])
                    p2 += 1
                p1 += shift
            else:
                if word[p1] != abbr[p2]:
                    return False
                p1 += 1
                p2 += 1
        return p1 == len(word) and p2 == len(abbr)
        
```

## 438 Find All Anagrams in a String M

### Description



Given two strings `s` and `p`, return _an array of all the start indices of_ `p`_'s anagrams in_ `s`. You may return the answer in **any order**.

An **Anagram** is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

&#x20;

**Example 1:**

```
Input: s = "cbaebabacd", p = "abc"
Output: [0,6]
Explanation:
The substring with start index = 0 is "cba", which is an anagram of "abc".
The substring with start index = 6 is "bac", which is an anagram of "abc".
```

**Example 2:**

```
Input: s = "abab", p = "ab"
Output: [0,1,2]
Explanation:
The substring with start index = 0 is "ab", which is an anagram of "ab".
The substring with start index = 1 is "ba", which is an anagram of "ab".
The substring with start index = 2 is "ab", which is an anagram of "ab".
```

&#x20;

**Constraints:**

* `1 <= s.length, p.length <= 3 * 104`
* `s` and `p` consist of lowercase English letters.

### Solution

```
// Some code
class Solution:
    def findAnagrams(self, s: str, p: str) -> List[int]:
        ns, np = len(s), len(p)
        counter_s = collections.Counter(s[0: np])
        counter_p = collections.Counter(p)
        
        res = []
        if counter_s == counter_p:
            res.append(0)
        for i in range(1, ns-np+1):
            if counter_s[s[i-1]] > 1:
                counter_s[s[i-1]] -= 1
            else:
                del counter_s[s[i-1]]
            counter_s[s[i+np-1]] += 1
            if counter_s == counter_p:
                res.append(i)
        return res
```
