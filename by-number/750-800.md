# 750-800

* [x] [760 Maximum Swap](750-800.md#760-maximum-swap)
*
* [x] [763 Partition Labels](750-800.md#763-partition-labels)
*
* [x] [790 Domino and Tromino Tiling](750-800.md#790-domino-and-tromino-tiling)
* [ ] 791
* [ ] 792
*

## 760 Maximum Swap

### Description



You are given an integer `num`. You can swap two digits at most once to get the maximum valued number.

Return _the maximum valued number you can get_.

&#x20;

**Example 1:**

```
Input: num = 2736
Output: 7236
Explanation: Swap the number 2 and the number 7.
```

**Example 2:**

```
Input: num = 9973
Output: 9973
Explanation: No swap.
```

&#x20;

**Constraints:**

* `0 <= num <= 108`

### Solution

```
// Some code
class Solution:
    def maximumSwap(self, num: int) -> int:
        # larger digit to swap, digit position of this digit
        high_digit = high_pos = 0
        
        # smaller digit to swap, digit position of this digit
        low_digit = low_pos = 0
        
        # greatest digit seen so far, digit postion of this digit
        cur_high_digit, cur_high_pos = -1, 0
        
        # current digit position
        pos = 1
        
        res = num
        while num: # iterate through digits from right to left
            digit = num % 10
            
            # if digit is greatest digit yet
            if digit > cur_high_digit:
                cur_high_digit, cur_high_pos = digit, pos
            
            # if digit is less than greatest digit yet
            elif digit < cur_high_digit:
                # set the digits to swap as the greatest digit yet, and this digit
                high_digit, high_pos = cur_high_digit, cur_high_pos
                low_digit, low_pos = digit, pos
            
            pos *= 10
            num //= 10
        
        # swap the digits
        res += high_digit*(low_pos - high_pos) + low_digit*(high_pos - low_pos)
        return res
```

## 763 Partition Labels

### Description



You are given a string `s`. We want to partition the string into as many parts as possible so that each letter appears in at most one part.

Note that the partition is done so that after concatenating all the parts in order, the resultant string should be `s`.

Return _a list of integers representing the size of these parts_.

&#x20;

**Example 1:**

```
Input: s = "ababcbacadefegdehijhklij"
Output: [9,7,8]
Explanation:
The partition is "ababcbaca", "defegde", "hijhklij".
This is a partition so that each letter appears in at most one part.
A partition like "ababcbacadefegde", "hijhklij" is incorrect, because it splits s into less parts.
```

**Example 2:**

```
Input: s = "eccbbbbdec"
Output: [10]
```

&#x20;

**Constraints:**

* `1 <= s.length <= 500`
* `s` consists of lowercase English letters.

### Solution

* Do some preprocessing, sort the list and then store the anchor

```
//
class Solution(object):
    def partitionLabels(self, S):
        last = {c: i for i, c in enumerate(S)}
        j = anchor = 0
        ans = []
        for i, c in enumerate(S):
            j = max(j, last[c])
            if i == j:
                ans.append(i - anchor + 1)
                anchor = i + 1
            
        return ans
```

## 790 Domino and Tromino Tiling

### Description

You have two types of tiles: a `2 x 1` domino shape and a tromino shape. You may rotate these shapes.

![](https://assets.leetcode.com/uploads/2021/07/15/lc-domino.jpg)

Given an integer n, return _the number of ways to tile an_ `2 x n` _board_. Since the answer may be very large, return it **modulo** `109 + 7`.

In a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/07/15/lc-domino1.jpg)

```
Input: n = 3
Output: 5
Explanation: The five different ways are show above.
```

**Example 2:**

```
Input: n = 1
Output: 1
```

**Constraints:**

* `1 <= n <= 1000`

### Solution

![](<../.gitbook/assets/image (1) (1) (2).png>)

![](<../.gitbook/assets/image (2) (1) (2).png>)

```
// DP Opt
class Solution:
    def numTilings(self, n: int) -> int:
        MOD = 1_000_000_007
        if n <= 2:
            return n
        fPrevious = 1
        fCurrent = 2
        pCurrent = 1
        for k in range(3, n + 1):
            tmp = fCurrent
            fCurrent = (fCurrent + fPrevious + 2 * pCurrent) % MOD
            pCurrent = (pCurrent + fPrevious) % MOD
            fPrevious = tmp
        return fCurrent
```
