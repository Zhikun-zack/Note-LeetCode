# 500-550

* [x] [524 Longest Word in Dictionary through Deleting](500-550.md#524-longest-word-in-dictionary-through-deleting-m)



## 524 Longest Word in Dictionary through Deleting M

### Description



Given a string `s` and a string array `dictionary`, return _the longest string in the dictionary that can be formed by deleting some of the given string characters_. If there is more than one possible result, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.

&#x20;

**Example 1:**

```
Input: s = "abpcplea", dictionary = ["ale","apple","monkey","plea"]
Output: "apple"
```

**Example 2:**

```
Input: s = "abpcplea", dictionary = ["a","b","c"]
Output: "a"
```

&#x20;

**Constraints:**

* `1 <= s.length <= 1000`
* `1 <= dictionary.length <= 1000`
* `1 <= dictionary[i].length <= 1000`
* `s` and `dictionary[i]` consist of lowercase English letters.

### Solution

1. Two pointers
2. Solve two problems:&#x20;
   1. How to know whether string in dictionary can become s by deleting
   2. How to return by lexicographic order if len is equal
3. Problem 2: sort dictionary by len first then charactristic
4. Problem 1: Two pointers, if two pointers point at same value, go next both; else pointer1 ++

```
// O(len(s) N ) O(N)
class Solution:
    def findLongestWord(self, s: str, dictionary: List[str]) -> str:
        # sort based on len, if len equal based on lexicographical
        dictionary.sort(key = lambda x: (-len(x), x))
        for i in dictionary:
            # pointer1 for s; 2 for i 
            pointer1 = pointer2 = 0
            while pointer2 < len(i) and pointer1 < len(s):
                if s[pointer1] == i[pointer2]:
                    pointer2 += 1
                pointer1 += 1
            # remove the situation when pointer1 == len(s) and find i can not be the word delete by s
            if pointer2 == len(i):
                return i
        return ""
                
```

