# 650-700

* [x] [658 Find K Closest Elements](650-700.md#658-find-k-closest-elements-m)
*
* [x] [678 Valid Parenthesis String](650-700.md#678-valid-parenthesis-string-m)
*
* [x] [688 Knight Probability in Chessboard](650-700.md#688.-knight-probability-in-chessboard)
* [ ] 689
* [ ] 690
* [ ] 691
* [ ] 692
*

## 658 Find K Closest Elements M

### Description



Given a **sorted** integer array `arr`, two integers `k` and `x`, return the `k` closest integers to `x` in the array. The result should also be sorted in ascending order.

An integer `a` is closer to `x` than an integer `b` if:

* `|a - x| < |b - x|`, or
* `|a - x| == |b - x|` and `a < b`

&#x20;

**Example 1:**

```
Input: arr = [1,2,3,4,5], k = 4, x = 3
Output: [1,2,3,4]
```

**Example 2:**

```
Input: arr = [1,2,3,4,5], k = 4, x = -1
Output: [1,2,3,4]
```

&#x20;

**Constraints:**

* `1 <= k <= arr.length`
* `1 <= arr.length <= 104`
* `arr` is sorted in **ascending** order.
* `-104 <= arr[i], x <= 104`

### Solution

1.  Binary Search and Sliding window

    ```
    class Solution: def findClosestElements(self, arr: List[int], k: int, x: int) -> List[int]: 
        if len(arr) == k: return arr     
        
        left = bisect_left(arr, x) - 1
        right = left + 1
        
        while right - left - 1 < k:
            if left == -1:
                right += 1
                continue
            
            if right == len(arr) or abs(arr[left] - x) <= abs(arr[right] - x):
                left -= 1
            else:
                right += 1
            
        return arr[left+1: right]
    ```
2.  Sliding window find left bound

    [https://www.youtube.com/watch?v=o-YDQzHoaKM](https://www.youtube.com/watch?v=o-YDQzHoaKM)  7:25

    ```
    class Solution:
        def findClosestElements(self, arr: List[int], k: int, x: int) -> List[int]:
            # Initialize binary search bounds
            left = 0
            right = len(arr) - k
            
            # Binary search against the criteria described
            while left < right:
                mid = (left + right) // 2
                if x - arr[mid] > arr[mid + k] - x:
                    left = mid + 1
                else:
                    right = mid

            return arr[left:left + k]
    ```



## 678 Valid Parenthesis String M

### Description



Given a string `s` containing only three types of characters: `'('`, `')'` and `'*'`, return `true` _if_ `s` _is **valid**_.

The following rules define a **valid** string:

* Any left parenthesis `'('` must have a corresponding right parenthesis `')'`.
* Any right parenthesis `')'` must have a corresponding left parenthesis `'('`.
* Left parenthesis `'('` must go before the corresponding right parenthesis `')'`.
* `'*'` could be treated as a single right parenthesis `')'` or a single left parenthesis `'('` or an empty string `""`.

&#x20;

**Example 1:**

```
Input: s = "()"
Output: true
```

**Example 2:**

```
Input: s = "(*)"
Output: true
```

**Example 3:**

```
Input: s = "(*))"
Output: true
```

&#x20;

**Constraints:**

* `1 <= s.length <= 100`
* `s[i]` is `'('`, `')'` or `'*'`.

### Solution

Same as [https://leetcode-cn.com/problems/valid-parenthesis-string/solution/gong-shui-san-xie-yi-ti-shuang-jie-dong-801rq/](https://leetcode-cn.com/problems/valid-parenthesis-string/solution/gong-shui-san-xie-yi-ti-shuang-jie-dong-801rq/)

```
// Some code
class Solution(object):
    def checkValidString(self, s):
        lo = hi = 0
        for c in s:
            lo += 1 if c == '(' else -1
            hi += 1 if c != ')' else -1
            if hi < 0: break
            lo = max(lo, 0)
            print(lo, hi)

        return lo == 0
```

## 688. Knight Probability in Chessboard

### Description

On an `n x n` chessboard, a knight starts at the cell `(row, column)` and attempts to make exactly `k` moves. The rows and columns are **0-indexed**, so the top-left cell is `(0, 0)`, and the bottom-right cell is `(n - 1, n - 1)`.

A chess knight has eight possible moves it can make, as illustrated below. Each move is two cells in a cardinal direction, then one cell in an orthogonal direction.

![](https://assets.leetcode.com/uploads/2018/10/12/knight.png)

Each time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there.

The knight continues moving until it has made exactly `k` moves or has moved off the chessboard.

Return _the probability that the knight remains on the board after it has stopped moving_.

**Example 1:**

```
Input: n = 3, k = 2, row = 0, column = 0
Output: 0.06250
Explanation: There are two moves (to (1,2), (2,1)) that will keep the knight on the board.
From each of those positions, there are also two moves that will keep the knight on the board.
The total probability the knight stays on the board is 0.0625.
```

![](<../.gitbook/assets/image (2) (1) (1).png>)

**Example 2:**

```
Input: n = 1, k = 0, row = 0, column = 0
Output: 1.00000
```

### **Solution:**

* Using DP
* dp\[k]\[i]\[j]: numbers of ways to move to i j
* dp\[k]\[i]\[j] = sum( dp\[k-1]\[i+r]\[j+c] ): sum of 8 former position values

```
// Some code
class Solution(object):
    def knightProbability(self, N, K, r, c):
        dp = [[0] * N for _ in range(N)]
        dp[r][c] = 1
        for _ in range(K):
            dp2 = [[0] * N for _ in range(N)]
            for r, row in enumerate(dp):
                for c, val in enumerate(row):
                    for dr, dc in ((2,1),(2,-1),(-2,1),(-2,-1),
                                   (1,2),(1,-2),(-1,2),(-1,-2)):
                        if 0 <= r + dr < N and 0 <= c + dc < N:
                            dp2[r+dr][c+dc] += val / 8.0
            dp = dp2

        return sum(map(sum, dp))
```
