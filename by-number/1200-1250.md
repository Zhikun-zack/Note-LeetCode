# 1200-1250

* [x] [1218 Longest Arithmetic Subsequence of Given Difference](1200-1250.md#1218-longest-arithmetic-subsequence-of-given-difference-medium)
* [ ] 1219
* [ ] 1220
* [ ] 1221
* [x] 1248 Count Number of Nice Subarrays
*

## 1218 Longest Arithmetic Subsequence of Given Difference Medium

### Description

Given an integer array `arr` and an integer `difference`, return the length of the longest subsequence in `arr` which is an arithmetic sequence such that the difference between adjacent elements in the subsequence equals `difference`.

A **subsequence** is a sequence that can be derived from `arr` by deleting some or no elements without changing the order of the remaining elements.

**Example 1:**

```
Input: arr = [1,2,3,4], difference = 1
Output: 4
Explanation: The longest arithmetic subsequence is [1,2,3,4].
```

**Example 2:**

```
Input: arr = [1,3,5,7], difference = 1
Output: 1
Explanation: The longest arithmetic subsequence is any single element.
```

**Example 3:**

```
Input: arr = [1,5,7,8,5,3,4,2,1], difference = -2
Output: 4
Explanation: The longest arithmetic subsequence is [7,5,3,1].
```

**Constraints:**

* `1 <= arr.length <= 105`
* `-104 <= arr[i], difference <= 104`

### Solution

DP

* Not using list, but hashmap
* dp\[i] = dp\[i-diff] + 1
* init value of each dp is 0

```
// DP
class Solution:
    def longestSubsequence(self, arr: List[int], difference: int) -> int:
        dp = defaultdict(int)

        for a in arr:
            dp[a] = dp[a-difference] + 1
        return max(dp.values())
```

## 1248 Count Number of Nice Subarrays M

### Description



Given an array of integers `nums` and an integer `k`. A continuous subarray is called **nice** if there are `k` odd numbers on it.

Return _the number of **nice** sub-arrays_.

&#x20;

**Example 1:**

```
Input: nums = [1,1,2,1,1], k = 3
Output: 2
Explanation: The only sub-arrays with 3 odd numbers are [1,1,2,1] and [1,2,1,1].
```

**Example 2:**

```
Input: nums = [2,4,6], k = 1
Output: 0
Explanation: There is no odd numbers in the array.
```

**Example 3:**

```
Input: nums = [2,2,2,1,2,2,1,2,2,2], k = 2
Output: 16
```

&#x20;

**Constraints:**

* `1 <= nums.length <= 50000`
* `1 <= nums[i] <= 10^5`
* `1 <= k <= nums.length`

### Solution

[https://leetcode-cn.com/problems/count-number-of-nice-subarrays/solution/tong-ji-you-mei-zi-shu-zu-by-leetcode-solution/](https://leetcode-cn.com/problems/count-number-of-nice-subarrays/solution/tong-ji-you-mei-zi-shu-zu-by-leetcode-solution/)

```
// Some code
class Solution:
    def numberOfSubarrays(self, nums: List[int], k: int) -> int:
        count = [-1]
        ans = 0
        n = len(nums)
        for i in range(n):
            if nums[i] % 2 !=0:
                count.append(i)
        count.append(n)
        for i in range(1, len(count)-k):
            ans += ((count[i] - count[i-1]) * (count[i+k] - count[i+k-1]))
        return ans


```

##
