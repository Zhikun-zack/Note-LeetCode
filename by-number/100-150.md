# 100-150

* [x] 101 Symmetric Tree
* [x] [103 Binary Tree Zigzag Level Order Traversal](100-150.md#103-binary-tree-zigzag-level-order-traversal)
* [x] 105 Construct Binary Tree from Preorder and Inorder Traversal
* [x] 106 Construct Binary Tree from Inorder and Postorder Traversal
* [x] 107 Binary Tree Level Order Traversal II
* [x] 109 Convert Sorted List to Binary Search Tree&#x20;
* [x] 110 Balanced Binary Tree
* [x] 115 Distinct Subsequences
* [x] 116 Populating Next Right Pointers in Each Node
* [x] 117 Populating Next Right Pointers in Each Node II
* [x] [120 Triangle](100-150.md#120-triangle)
* [x] 124 Binary Tree Maximum Path Sum
* [x] 129 Sum Root to Leaf Numbers
* [x] 141 Linked List Cycle
* [x] 142 Linked List Cycle II
* [x] 144 Binary Tree Preorder Traversal
* [x] 145&#x20;

## 101 Symmetric Tree E

### D



Given the `root` of a binary tree, _check whether it is a mirror of itself_ (i.e., symmetric around its center).

&#x20;

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg)

```
Input: root = [1,2,2,3,4,4,3]
Output: true
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg)

```
Input: root = [1,2,2,null,3,null,3]
Output: false
```

&#x20;

**Constraints:**

* The number of nodes in the tree is in the range `[1, 1000]`.
* `-100 <= Node.val <= 100`

### S

Recursion

```
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        return self.isMirror(root, root)
    def isMirror(self,node1: TreeNode, node2: TreeNode):
        if(node1 is None and node2 is None): return True
        if(node1 is None or node2 is None): return False
        if(node1.val != node2.val): return False
        return self.isMirror(node1.left, node2.right) and self.isMirror(node1.right, node2.left)
            
```



## 103 Binary Tree Zigzag Level Order Traversal

### Description



Given the `root` of a binary tree, return _the zigzag level order traversal of its nodes' values_. (i.e., from left to right, then right to left for the next level and alternate between).

&#x20;

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)

```
Input: root = [3,9,20,null,null,15,7]
Output: [[3],[20,9],[15,7]]
```

**Example 2:**

```
Input: root = [1]
Output: [[1]]
```

**Example 3:**

```
Input: root = []
Output: []
```

&#x20;

**Constraints:**

* The number of nodes in the tree is in the range `[0, 2000]`.
* `-100 <= Node.val <= 100`

### Solution

1. BFS

* Normal BFS is just create a deque, setting root as the first value, using while loop to iterate, each loop pop first value and push the popped node's left and right node into deque from the back.
* This time change a little bit, first add two values as init value, root node and None&#x20;
* When visiting None, means this layer has been all visited and at the same time, the queue contains all the next layer's nodes
* Then just append new None to separate  the new layer

```
// Some code
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        res = []
        level_list = deque()
        if root is None:
            return res
        
        node_queue = deque([root, None])
        reverse = False
        
        while len(node_queue) > 0:
            cur_node = node_queue.popleft()
            
            if cur_node:
                if reverse:
                    level_list.appendleft(cur_node.val)
                else:
                    level_list.append(cur_node.val)
                
                if cur_node.left:
                    node_queue.append(cur_node.left)
                if cur_node.right:
                    node_queue.append(cur_node.right)
            else:
                res.append(level_list)
                if len(node_queue) > 0:
                    node_queue.append(None)
                level_list = deque()
                reverse = not reverse
                
        return res
```

## 105 Construct Binary Tree from Preorder and Inorder Traversal M

### D



Given two integer arrays `preorder` and `inorder` where `preorder` is the preorder traversal of a binary tree and `inorder` is the inorder traversal of the same tree, construct and return _the binary tree_.

&#x20;

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)

```
Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
Output: [3,9,20,null,null,15,7]
```

**Example 2:**

```
Input: preorder = [-1], inorder = [-1]
Output: [-1]
```

### S

* Preorder provide root node
* Inorder provide child tree
* Using recursion to build the whole tree
* Using hash map to store a key value pair for getting the index of root in inorder faster

```
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        def construct(preorder, inorder, start, end):
            if start > end: return None
            root_val = preorder.pop()
            index = inorder_map[root_val]
            root = TreeNode(root_val)
            
            root.left = construct(preorder, inorder, start, index-1)
            root.right = construct(preorder, inorder, index+1, end)
            
            return root
        # preorder.pop is pop the last element in the list, not the first one
        preorder.reverse()
        
        # Mapping for index and value, key is value, value is index
        # For better pick up the index of certain value in inorder list
        inorder_map = {}
        for v, i in enumerate(inorder):
            inorder_map[i] = v
            
        return construct(preorder, inorder, 0, len(preorder) - 1)
        
        

```

## 106 Construct Binary Tree from Inorder and Postorder Traversal M

### D



Given two integer arrays `inorder` and `postorder` where `inorder` is the inorder traversal of a binary tree and `postorder` is the postorder traversal of the same tree, construct and return _the binary tree_.

&#x20;

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)

```
Input: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
Output: [3,9,20,null,null,15,7]
```

**Example 2:**

```
Input: inorder = [-1], postorder = [-1]
Output: [-1]
```

### S

* Postorder traversal's last element may be the root
* Inorder traversal provide the structure of the tree

```
class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:
        def helper(in_left, in_right):
            # if there is no elements to construct subtrees
            if in_left > in_right:
                return None
            
            # pick up the last element as a root
            val = postorder.pop()
            root = TreeNode(val)

            # root splits inorder list
            # into left and right subtrees
            index = idx_map[val]
 
            # build right subtree
            root.right = helper(index + 1, in_right)
            # build left subtree
            root.left = helper(in_left, index - 1)
            return root
        
        # build a hashmap value -> its index
        idx_map = {val:idx for idx, val in enumerate(inorder)} 
        return helper(0, len(inorder) - 1)
```

## 107 Binary Tree Level Order Traversal II M

### D



Given the `root` of a binary tree, return _the bottom-up level order traversal of its nodes' values_. (i.e., from left to right, level by level from leaf to root).

&#x20;

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)

```
Input: root = [3,9,20,null,null,15,7]
Output: [[15,7],[9,20],[3]]
```

**Example 2:**

```
Input: root = [1]
Output: [[1]]
```

**Example 3:**

```
Input: root = []
Output: []
```

### S

* BFS&#x20;
* Reverse

```
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root: return []
        level = collections.deque([root])
        res = []
        
        while level:
            n = len(level)
            level_nodes = []
            while n>0:
                node = level.popleft()
                
                level_nodes.append(node.val)
                
                if node.left:
                    level.append(node.left)
                if node.right:
                    level.append(node.right)
                n -= 1
            res.append(level_nodes)
        return res[::-1]
```

## 108 Convert Sorted Array to Binary Search Tree E

### D



Given an integer array `nums` where the elements are sorted in **ascending order**, convert _it to a **height-balanced** binary search tree_.

A **height-balanced** binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.

&#x20;

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg)

```
Input: nums = [-10,-3,0,5,9]
Output: [0,-3,9,-10,null,5]
Explanation: [0,-10,5,null,-3,null,9] is also accepted:
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/02/18/btree.jpg)

```
Input: nums = [1,3]
Output: [3,1]
Explanation: [1,null,3] and [3,1] are both height-balanced BSTs.
```

### S

```
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        def helper(start, end):
            if start > end:
                return None
            
            p = (start + end) // 2
            
            root = TreeNode(nums[p])
            root.left = helper(start, p-1)
            root.right = helper(p+1, end)
            return root
        return helper(0, len(nums)-1)
```

## 109 Convert Sorted List to Binary Search Tree M

### D



Given the `head` of a singly linked list where elements are **sorted in ascending order**, convert it to a height balanced BST.

For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of _every_ node never differ by more than 1.

&#x20;

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/08/17/linked.jpg)

```
Input: head = [-10,-3,0,5,9]
Output: [0,-3,9,-10,null,5]
Explanation: One possible answer is [0,-3,9,-10,null,5], which represents the shown height balanced BST.
```

**Example 2:**

```
Input: head = []
Output: []
```

&#x20;

**Constraints:**

* The number of nodes in `head` is in the range `[0, 2 * 104]`.
* `-105 <= Node.val <= 105`

### S

```
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:
        # Using slow and fast pointers to find the middle of the linked list
        def findMiddle(head):
            # Used to disconnect the left portion with middle node
            # Keep it equal to one node before slow pointer, after finding the middle node, 
            #   set the next node of prev equal to None
            prev = None 
            
            slow = head
            fast = head
            
            while fast and fast.next:
                prev = slow
                slow = slow.next
                fast = fast.next.next
            
            # If slow is head, then prev is None not prev.next is None
            if prev:
                # Normal situation, when slow is not the head node
                prev.next = None
            return slow
        
        if not head: return None
        
        # Mid linked list
        mid = findMiddle(head)
        resNode = TreeNode(mid.val)
        
        if head == mid:
            return resNode

        resNode.left = self.sortedListToBST(head)
        resNode.right = self.sortedListToBST(mid.next)
        
        return resNode
```

## 110 Balanced Binary Tree E

### D



Given a binary tree, determine if it is height-balanced.

For this problem, a height-balanced binary tree is defined as:

> a binary tree in which the left and right subtrees of _every_ node differ in height by no more than 1.

&#x20;

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/10/06/balance\_1.jpg)

```
Input: root = [3,9,20,null,null,15,7]
Output: true
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2020/10/06/balance\_2.jpg)

```
Input: root = [1,2,2,3,3,null,null,4,4]
Output: false
```

**Example 3:**

```
Input: root = []
Output: true
```

### S

* Bottom up recursion
* Difficulty is what to return in the recursion function

```
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    # Return whether or not the tree at root is balanced while also returning
    # the tree's height
    def isBalancedHelper(self, root: TreeNode) -> (bool, int):
        # An empty tree is balanced and has height -1
        if not root:
            return True, -1
        
        # Check subtrees to see if they are balanced. 
        leftIsBalanced, leftHeight = self.isBalancedHelper(root.left)
        if not leftIsBalanced:
            return False, 0
        rightIsBalanced, rightHeight = self.isBalancedHelper(root.right)
        if not rightIsBalanced:
            return False, 0
        
        # If the subtrees are balanced, check if the current tree is balanced
        # using their height
        return (abs(leftHeight - rightHeight) < 2), 1 + max(leftHeight, rightHeight)
        
    def isBalanced(self, root: TreeNode) -> bool:
        return self.isBalancedHelper(root)[0]

            
            
```

* Top down recursion
* Go to the next level when make sure this level is balanced

```
// Some code
# Top down recursion way
class Solution:
    # Compute the tree's height via recursion
    # This function is still bottom up, from the leaf node to root node
    def height(self, root: TreeNode) -> int:
        # An empty tree has height -1
        if not root:
            return -1
        return 1 + max(self.height(root.left), self.height(root.right))
    
    # This function is top down, first judge whether root is balanced tree then its child node
    def isBalanced(self, root: TreeNode) -> bool:
        # An empty tree satisfies the definition of a balanced tree
        if not root:
            return True

        # Check if subtrees have height within 1. If they do, check if the
        # subtrees are balanced
        return abs(self.height(root.left) - self.height(root.right)) < 2 \
            and self.isBalanced(root.left) \
            and self.isBalanced(root.right)
        
```

## 115 Distinct Subsequences H

### D



Given two strings `s` and `t`, return _the number of distinct subsequences of `s` which equals `t`_.

A string's **subsequence** is a new string formed from the original string by deleting some (can be none) of the characters without disturbing the remaining characters' relative positions. (i.e., `"ACE"` is a subsequence of `"ABCDE"` while `"AEC"` is not).

The test cases are generated so that the answer fits on a 32-bit signed integer.

&#x20;

**Example 1:**

```
Input: s = "rabbbit", t = "rabbit"
Output: 3
Explanation:
As shown below, there are 3 ways you can generate "rabbit" from S.
rabbbit
rabbbit
rabbbit
```

**Example 2:**

```
Input: s = "babgbag", t = "bag"
Output: 5
Explanation:
As shown below, there are 5 ways you can generate "bag" from S.
babgbag
babgbag
babgbag
babgbag
babgbag
```

### S

```
// Some code
class Solution:
    def numDistinct(self, s: str, t: str) -> int:
        
        M, N = len(s), len(t)
        
        # Dynamic Programming table
        dp = [0 for j in range(N)] 
        
        # Iterate over the strings in reverse so as to
        # satisfy the way we've modeled our recursive solution
        for i in range(M - 1, -1, -1):
            
            # At each step we start with the last value in
            # the row which is always 1. Notice how we are
            # starting the loop from N - 1 instead of N like
            # in the previous solution.
            prev = 1
            
            for j in range(N - 1, -1, -1):
          
                # Record the current value in this cell so that
                # we can use it to calculate the value of dp[j - 1]
                old_dpj = dp[j]
        
                # If the characters match, we add the
                # result of the next recursion call (in this
                # case, the value of a cell in the dp table
                
                # dp[j] is the prev value which same as the dp[i+1][j]
                # So no need to add other values, just add the prev is enough
                if s[i] == t[j]:
                    dp[j] += prev
                
                # Update the prev variable
                prev = old_dpj    
        
        return dp[0]
```

```
// Space O(1)
class Solution:
    def numDistinct(self, s: str, t: str) -> int:
        
        M, N = len(s), len(t)
        
        # Dynamic Programming table
        dp = [0 for j in range(N)] 
        
        # Iterate over the strings in reverse so as to
        # satisfy the way we've modeled our recursive solution
        for i in range(M - 1, -1, -1):
            
            # At each step we start with the last value in
            # the row which is always 1. Notice how we are
            # starting the loop from N - 1 instead of N like
            # in the previous solution.
            prev = 1
            
            for j in range(N - 1, -1, -1):
          
                # Record the current value in this cell so that
                # we can use it to calculate the value of dp[j - 1]
                old_dpj = dp[j]
        
                # If the characters match, we add the
                # result of the next recursion call (in this
                # case, the value of a cell in the dp table
                
                # dp[j] is the prev value which same as the dp[i+1][j]
                # So no need to add other values, just add the prev is enough
                if s[i] == t[j]:
                    dp[j] += prev
                
                # Update the prev variable
                prev = old_dpj    
        
        return dp[0]
```

## 116 Populating Next Right Pointers in Each Node M

### D



You are given a **perfect binary tree** where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:

```
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to `NULL`.

Initially, all next pointers are set to `NULL`.

&#x20;

**Example 1:**

![](https://assets.leetcode.com/uploads/2019/02/14/116\_sample.png)

```
Input: root = [1,2,3,4,5,6,7]
Output: [1,#,2,3,#,4,5,6,7,#]
Explanation: Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level.
```

**Example 2:**

```
Input: root = []
Output: []
```

&#x20;

**Constraints:**

* The number of nodes in the tree is in the range `[0, 212 - 1]`.
* `-1000 <= Node.val <= 1000`

&#x20;

**Follow-up:**

* You may only use constant extra space.
* The recursive approach is fine. You may assume implicit stack space does not count as extra space for this problem.

### S

BFS

```
"""
# Definition for a Node.
class Node:
    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):
        self.val = val
        self.left = left
        self.right = right
        self.next = next
"""

class Solution:
    def connect(self, root: 'Optional[Node]') -> 'Optional[Node]':
        if not root:
            return root
        
        queue = collections.deque([root])
        
        while queue:
            level_len = len(queue)
            for i in range(level_len):
                node = queue.popleft()
                if i < level_len - 1:
                    node.next = queue[0]
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
        return root
```

Constant space&#x20;

* node.left.next = node.right
* if node.next != none
  * node.right.next = node.next.left
  * else: node.right.next = None
* Move from top to bottom
* Since we need to calculate two layers each time, so when node.left == None, we can stop loop

```
class Solution:
    def connect(self, root: 'Node') -> 'Node':
        
        if not root:
            return root
        
        # Start with the root node. There are no next pointers
        # that need to be set up on the first level
        # loop through all levels, only represent left most node of each level
        leftmost = root
        
        # Once we reach the final level, we are done
        while leftmost.left:
            
            # Iterate the "linked list" starting from the head
            # node and using the next pointers, establish the 
            # corresponding links for the next level
            # Loop through all node in the same level
            head = leftmost
            while head:
                
                # CONNECTION 1
                head.left.next = head.right
                
                # CONNECTION 2
                if head.next:
                    head.right.next = head.next.left
                
                # Progress along the list (nodes on the current level)
                head = head.next
            
            # Move onto the next level
            leftmost = leftmost.left
        
        return root 
```

## 117 Populating Next Right Pointers in Each Node II M

### D



Given a binary tree

```
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to `NULL`.

Initially, all next pointers are set to `NULL`.

&#x20;

**Example 1:**

![](https://assets.leetcode.com/uploads/2019/02/15/117\_sample.png)

```
Input: root = [1,2,3,4,5,null,7]
Output: [1,#,2,3,#,4,5,7,#]
Explanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level.
```

**Example 2:**

```
Input: root = []
Output: []
```

&#x20;

**Constraints:**

* The number of nodes in the tree is in the range `[0, 6000]`.
* `-100 <= Node.val <= 100`

&#x20;

**Follow-up:**

* You may only use constant extra space.
* The recursive approach is fine. You may assume implicit stack space does not count as extra space for this problem.

### S

1. Normal BFS
2. O(1) space complex way

```
"""
# Definition for a Node.
class Node:
    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):
        self.val = val
        self.left = left
        self.right = right
        self.next = next
"""

class Solution:
    def connect(self, root: 'Node') -> 'Node':
        if not root:
            return root
        
        queue = collections.deque();
        queue.append(root)
        
        while queue:
            queue_len = len(queue)

            for i in range(queue_len):
                node = queue.popleft()
                
                if i <= queue_len-2:
                    node.next = queue[0]
                
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
        return root
                
```

[https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/solution/](https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/solution/) second solution

* cur\_upper: the pointer used to traverse all the nodes in the same level; this level should already been linked
* prev\_down: the pointer used to traverse all the nodes in the next level, this level has not been linked
* leftmost: the left most node of the level which still linking

```
"""
# Definition for a Node.
class Node:
    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):
        self.val = val
        self.left = left
        self.right = right
        self.next = next
"""

class Solution:
    def precessChild(self, node, prev, leftmost):
        if node:
            if prev:
                prev.next = node
            else:
                leftmost = node
            prev = node
        return prev, leftmost
    def connect(self, root: 'Node') -> 'Node':
        if not root:
            return root
        
        leftmost = root
        while leftmost:
            cur_upper = leftmost
            leftmost = None
            prev_down = None
            
            while cur_upper:
                prev_down, leftmost = self.precessChild(cur_upper.left, prev_down, leftmost)
                prev_down, leftmost = self.precessChild(cur_upper.right, prev_down, leftmost)
                
                cur_upper = cur_upper.next
        return root
```

## 120 Triangle

### Description

Given a `triangle` array, return _the minimum path sum from top to bottom_.

For each step, you may move to an adjacent number of the row below. More formally, if you are on index `i` on the current row, you may move to either index `i` or index `i + 1` on the next row.

**Example 1:**

```
Input: triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
Output: 11
Explanation: The triangle looks like:
   2
  3 4
 6 5 7
4 1 8 3
The minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).
```

**Example 2:**

```
Input: triangle = [[-10]]
Output: -10
```

### Solution

```
// DP Top to buttom without space optimization
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        r_n = len(triangle)
        c_n = len(triangle[r_n - 1])
        
        if r_n == 1:
            return triangle[0][0]
        
        dp =[ [0 for _ in range(c_n)] for _ in range(r_n)]
        
        // init
        dp[0][0] = triangle[0][0]
        
        for i in range(1, r_n):
            for j in range(i+1):
                // if at the first column, will not have j-1 value
                if j - 1 < 0:
                    dp[i][j] = dp[i-1][j] + triangle[i][j]
                // if at the last column, will not have j
                elif j == i:
                    dp[i][j] = dp[i-1][j-1] + triangle[i][j]
                else:
                    dp[i][j] = min(dp[i-1][j] + triangle[i][j], dp[i-1][j-1] + triangle[i][j])
        print(dp)
        return min(dp[r_n - 1])
```

```
// DP Top-buttom With space optimi, store all in triangle
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        r_n = len(triangle)
        c_n = len(triangle[r_n - 1])
        
        if r_n == 1:
            return triangle[0][0]
        
        for i in range(1, r_n):
            for j in range(i+1):
                if j - 1 < 0:
                    triangle[i][j] += triangle[i-1][j]
                elif j == i:
                    triangle[i][j] += triangle[i-1][j-1]
                else:
                    triangle[i][j] = min(triangle[i-1][j] + triangle[i][j], triangle[i-1][j-1] + triangle[i][j])
        return min(triangle[r_n - 1])
```

```
// DP b to top
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        below_row = triangle[-1] 
        n = len(triangle)
        for row in reversed(range(n - 1)):     
            curr_row = []
            for col in range(row + 1):
                smallest_below = min(below_row[col], below_row[col + 1])
                curr_row.append(triangle[row][col] + smallest_below)
            below_row = curr_row
        return below_row[0]
```

## 143 Reorder List

### Description



You are given the head of a singly linked-list. The list can be represented as:

```
L0 → L1 → … → Ln - 1 → Ln
```

_Reorder the list to be on the following form:_

```
L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …
```

You may not modify the values in the list's nodes. Only nodes themselves may be changed.

&#x20;

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/03/04/reorder1linked-list.jpg)

```
Input: head = [1,2,3,4]
Output: [1,4,2,3]
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/03/09/reorder2-linked-list.jpg)

```
Input: head = [1,2,3,4,5]
Output: [1,5,2,4,3]
```

&#x20;

**Constraints:**

* The number of nodes in the list is in the range `[1, 5 * 104]`.
* `1 <= Node.val <= 1000`

### Solution

{% embed url="https://leetcode.com/problems/reorder-list/solution" %}

```
// Some code
class Solution:
    def reorderList(self, head: ListNode) -> None:
        if not head:
            return 
        
        # find the middle of linked list [Problem 876]
        # in 1->2->3->4->5->6 find 4 
        slow = fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next 
            
        # reverse the second part of the list [Problem 206]
        # convert 1->2->3->4->5->6 into 1->2->3->4 and 6->5->4
        # reverse the second half in-place
        prev, curr = None, slow
        while curr:
            curr.next, prev, curr = prev, curr, curr.next       

        # merge two sorted linked lists [Problem 21]
        # merge 1->2->3->4 and 6->5->4 into 1->6->2->5->3->4
        first, second = head, prev
        while second.next:
            first.next, first = second, first.next
            second.next, second = first, second.next
```

## 124 Binary Tree Maximum Path Sum H

### D



A **path** in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence **at most once**. Note that the path does not need to pass through the root.

The **path sum** of a path is the sum of the node's values in the path.

Given the `root` of a binary tree, return _the maximum **path sum** of any **non-empty** path_.

&#x20;

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg)

```
Input: root = [1,2,3]
Output: 6
Explanation: The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg)

```
Input: root = [-10,9,20,null,null,15,7]
Output: 42
Explanation: The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42.
```

### S

```
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxPathSum(self, root: Optional[TreeNode]) -> int:
        # Could be negative value
        self.res = float("-inf")
        
        def dfs(node):
            if not node: return 0
            
            # the node may have negative value 
            # Have to make sure that the l_max is at least larger than 0
            l_max = max(dfs(node.left), 0)
            r_max = max(dfs(node.right), 0)

            self.res = max(self.res, l_max+r_max+node.val)
            
            return max(l_max+node.val, r_max+node.val)
        
        dfs(root)
        
        return self.res
```

## 129 Sum Root to Leaf Numbers M

### D



You are given the `root` of a binary tree containing digits from `0` to `9` only.

Each root-to-leaf path in the tree represents a number.

* For example, the root-to-leaf path `1 -> 2 -> 3` represents the number `123`.

Return _the total sum of all root-to-leaf numbers_. Test cases are generated so that the answer will fit in a **32-bit** integer.

A **leaf** node is a node with no children.

&#x20;

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/02/19/num1tree.jpg)

```
Input: root = [1,2,3]
Output: 25
Explanation:
The root-to-leaf path 1->2 represents the number 12.
The root-to-leaf path 1->3 represents the number 13.
Therefore, sum = 12 + 13 = 25.
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/02/19/num2tree.jpg)

```
Input: root = [4,9,0,5,1]
Output: 1026
Explanation:
The root-to-leaf path 4->9->5 represents the number 495.
The root-to-leaf path 4->9->1 represents the number 491.
The root-to-leaf path 4->0 represents the number 40.
Therefore, sum = 495 + 491 + 40 = 1026.
```

&#x20;

**Constraints:**

* The number of nodes in the tree is in the range `[1, 1000]`.
* `0 <= Node.val <= 9`
* The depth of the tree will not exceed `10`.

### S

```
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def sumNumbers(self, root: Optional[TreeNode]) -> int:
        def dfs(node, curr):
            nonlocal res;
            if node:
                curr = curr*10 + node.val;
                # if it is a leaf node
                if not(node.left or node.right):
                    res += curr
                
                dfs(node.left, curr);
                dfs(node.right, curr);
        res = 0
        dfs(root, 0);
        return res;
```

## 141 Linked List Cycle E

### D

Given `head`, the head of a linked list, determine if the linked list has a cycle in it.

There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the `next` pointer. Internally, `pos` is used to denote the index of the node that tail's `next` pointer is connected to. **Note that `pos` is not passed as a parameter**.

Return `true` _if there is a cycle in the linked list_. Otherwise, return `false`.

&#x20;

**Example 1:**

![](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png)

```
Input: head = [3,2,0,-4], pos = 1
Output: true
Explanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist\_test2.png)

```
Input: head = [1,2], pos = 0
Output: true
Explanation: There is a cycle in the linked list, where the tail connects to the 0th node.
```

**Example 3:**

![](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist\_test3.png)

```
Input: head = [1], pos = -1
Output: false
Explanation: There is no cycle in the linked list.
```

&#x20;

**Constraints:**

* The number of the nodes in the list is in the range `[0, 104]`.
* `-105 <= Node.val <= 105`
* `pos` is `-1` or a **valid index** in the linked-list.

&#x20;

**Follow up:** Can you solve it using `O(1)` (i.e. constant) memory?

### S

* Two pointers
* Difficulty: how to set the while situation

```
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        if head is None:
            return False 
        
        fast, slow = head.next, head
        # Need to make sure fast.next also not None, because next fast will be fast.next.next
        while fast and fast.next:
            if fast == slow:
                return True

            fast = fast.next.next
            slow = slow.next
        return False
```

## 142 Linked List Cycle II M

### D



Given the `head` of a linked list, return _the node where the cycle begins. If there is no cycle, return_ `null`.

There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the `next` pointer. Internally, `pos` is used to denote the index of the node that tail's `next` pointer is connected to (**0-indexed**). It is `-1` if there is no cycle. **Note that** `pos` **is not passed as a parameter**.

**Do not modify** the linked list.

&#x20;

**Example 1:**

![](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png)

```
Input: head = [3,2,0,-4], pos = 1
Output: tail connects to node index 1
Explanation: There is a cycle in the linked list, where tail connects to the second node.
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist\_test2.png)

```
Input: head = [1,2], pos = 0
Output: tail connects to node index 0
Explanation: There is a cycle in the linked list, where tail connects to the first node.
```

**Example 3:**

![](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist\_test3.png)

```
Input: head = [1], pos = -1
Output: no cycle
Explanation: There is no cycle in the linked list.
```

&#x20;

**Constraints:**

* The number of the nodes in the list is in the range `[0, 104]`.
* `-105 <= Node.val <= 105`
* `pos` is `-1` or a **valid index** in the linked-list.

### S

* Using fast and slow pointer to check whether there exist loop
* Find the intersect point
* Create another two pointers, one from the beginning of the linked list another from intersect point, each one move one step each time
* Intersection of these two pointers will be the entrance of loop

```
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head: return None
        
        fast, slow = head, head
        meet_point = None
        
        while fast is not None and fast.next is not None:
            fast = fast.next.next
            slow = slow.next
            if fast == slow:
                meet_point = fast
                break
                
        if meet_point is None: return None
        
        p = head
        while p != meet_point:
            p = p.next
            meet_point = meet_point.next
        
        return meet_point
        
```

## 144 Binary Tree Preorder Traversal  E

### D



Given the `root` of a binary tree, return _the preorder traversal of its nodes' values_.

&#x20;

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/09/15/inorder\_1.jpg)

```
Input: root = [1,null,2,3]
Output: [1,2,3]
```

**Example 2:**

```
Input: root = []
Output: []
```

**Example 3:**

```
Input: root = [1]
Output: [1]
```

### S

```
// Some code
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        if root is None: return []
        
        stack, res = [root, ], []
        
        while stack:
            node = stack.pop()
            if node is not None:
                res.append(node.val)
                if node.right is not None:
                    stack.append(node.right)
                if node.left is not None:
                    stack.append(node.left)
        return res
```

## 145 Binary Tree Postorder Traversal

### D



Given the `root` of a binary tree, return _the postorder traversal of its nodes' values_.

&#x20;

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/08/28/pre1.jpg)

```
Input: root = [1,null,2,3]
Output: [3,2,1]
```

**Example 2:**

```
Input: root = []
Output: []
```

**Example 3:**

```
Input: root = [1]
Output: [1]
```

### S

```
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        if not root: return []
        
        return self.postorderTraversal(root.left) + self.postorderTraversal(root.right) + [root.val]
    
```
