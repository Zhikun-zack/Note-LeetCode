# 100-150

* [x] 101 Symmetric Tree
* [x] [103 Binary Tree Zigzag Level Order Traversal](100-150.md#103-binary-tree-zigzag-level-order-traversal)
* [x] 116 Populating Next Right Pointers in Each Node
* [x] [120 Triangle](100-150.md#120-triangle)

## 101 Symmetric Tree E

### D



Given the `root` of a binary tree, _check whether it is a mirror of itself_ (i.e., symmetric around its center).

&#x20;

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg)

```
Input: root = [1,2,2,3,4,4,3]
Output: true
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg)

```
Input: root = [1,2,2,null,3,null,3]
Output: false
```

&#x20;

**Constraints:**

* The number of nodes in the tree is in the range `[1, 1000]`.
* `-100 <= Node.val <= 100`

### S

Recursion

```
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        return self.isMirror(root, root)
    def isMirror(self,node1: TreeNode, node2: TreeNode):
        if(node1 is None and node2 is None): return True
        if(node1 is None or node2 is None): return False
        if(node1.val != node2.val): return False
        return self.isMirror(node1.left, node2.right) and self.isMirror(node1.right, node2.left)
            
```



## 103 Binary Tree Zigzag Level Order Traversal

### Description



Given the `root` of a binary tree, return _the zigzag level order traversal of its nodes' values_. (i.e., from left to right, then right to left for the next level and alternate between).

&#x20;

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)

```
Input: root = [3,9,20,null,null,15,7]
Output: [[3],[20,9],[15,7]]
```

**Example 2:**

```
Input: root = [1]
Output: [[1]]
```

**Example 3:**

```
Input: root = []
Output: []
```

&#x20;

**Constraints:**

* The number of nodes in the tree is in the range `[0, 2000]`.
* `-100 <= Node.val <= 100`

### Solution

1. BFS

* Normal BFS is just create a deque, setting root as the first value, using while loop to iterate, each loop pop first value and push the popped node's left and right node into deque from the back.
* This time change a little bit, first add two values as init value, root node and None&#x20;
* When visiting None, means this layer has been all visited and at the same time, the queue contains all the next layer's nodes
* Then just append new None to separate  the new layer

```
// Some code
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        res = []
        level_list = deque()
        if root is None:
            return res
        
        node_queue = deque([root, None])
        reverse = False
        
        while len(node_queue) > 0:
            cur_node = node_queue.popleft()
            
            if cur_node:
                if reverse:
                    level_list.appendleft(cur_node.val)
                else:
                    level_list.append(cur_node.val)
                
                if cur_node.left:
                    node_queue.append(cur_node.left)
                if cur_node.right:
                    node_queue.append(cur_node.right)
            else:
                res.append(level_list)
                if len(node_queue) > 0:
                    node_queue.append(None)
                level_list = deque()
                reverse = not reverse
                
        return res
```

## 116 Populating Next Right Pointers in Each Node M

### D



You are given a **perfect binary tree** where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:

```
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to `NULL`.

Initially, all next pointers are set to `NULL`.

&#x20;

**Example 1:**

![](https://assets.leetcode.com/uploads/2019/02/14/116\_sample.png)

```
Input: root = [1,2,3,4,5,6,7]
Output: [1,#,2,3,#,4,5,6,7,#]
Explanation: Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level.
```

**Example 2:**

```
Input: root = []
Output: []
```

&#x20;

**Constraints:**

* The number of nodes in the tree is in the range `[0, 212 - 1]`.
* `-1000 <= Node.val <= 1000`

&#x20;

**Follow-up:**

* You may only use constant extra space.
* The recursive approach is fine. You may assume implicit stack space does not count as extra space for this problem.

### S

BFS

```
"""
# Definition for a Node.
class Node:
    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):
        self.val = val
        self.left = left
        self.right = right
        self.next = next
"""

class Solution:
    def connect(self, root: 'Optional[Node]') -> 'Optional[Node]':
        if not root:
            return root
        
        queue = collections.deque([root])
        
        while queue:
            level_len = len(queue)
            for i in range(level_len):
                node = queue.popleft()
                if i < level_len - 1:
                    node.next = queue[0]
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
        return root
```

Constant space&#x20;

* node.left.next = node.right
* if node.next != none
  * node.right.next = node.next.left
  * else: node.right.next = None
* Move from top to bottom
* Since we need to calculate two layers each time, so when node.left == None, we can stop loop

```
class Solution:
    def connect(self, root: 'Node') -> 'Node':
        
        if not root:
            return root
        
        # Start with the root node. There are no next pointers
        # that need to be set up on the first level
        # loop through all levels, only represent left most node of each level
        leftmost = root
        
        # Once we reach the final level, we are done
        while leftmost.left:
            
            # Iterate the "linked list" starting from the head
            # node and using the next pointers, establish the 
            # corresponding links for the next level
            # Loop through all node in the same level
            head = leftmost
            while head:
                
                # CONNECTION 1
                head.left.next = head.right
                
                # CONNECTION 2
                if head.next:
                    head.right.next = head.next.left
                
                # Progress along the list (nodes on the current level)
                head = head.next
            
            # Move onto the next level
            leftmost = leftmost.left
        
        return root 
```

## 120 Triangle

### Description

Given a `triangle` array, return _the minimum path sum from top to bottom_.

For each step, you may move to an adjacent number of the row below. More formally, if you are on index `i` on the current row, you may move to either index `i` or index `i + 1` on the next row.

**Example 1:**

```
Input: triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
Output: 11
Explanation: The triangle looks like:
   2
  3 4
 6 5 7
4 1 8 3
The minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).
```

**Example 2:**

```
Input: triangle = [[-10]]
Output: -10
```

### Solution

```
// DP Top to buttom without space optimization
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        r_n = len(triangle)
        c_n = len(triangle[r_n - 1])
        
        if r_n == 1:
            return triangle[0][0]
        
        dp =[ [0 for _ in range(c_n)] for _ in range(r_n)]
        
        // init
        dp[0][0] = triangle[0][0]
        
        for i in range(1, r_n):
            for j in range(i+1):
                // if at the first column, will not have j-1 value
                if j - 1 < 0:
                    dp[i][j] = dp[i-1][j] + triangle[i][j]
                // if at the last column, will not have j
                elif j == i:
                    dp[i][j] = dp[i-1][j-1] + triangle[i][j]
                else:
                    dp[i][j] = min(dp[i-1][j] + triangle[i][j], dp[i-1][j-1] + triangle[i][j])
        print(dp)
        return min(dp[r_n - 1])
```

```
// DP Top-buttom With space optimi, store all in triangle
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        r_n = len(triangle)
        c_n = len(triangle[r_n - 1])
        
        if r_n == 1:
            return triangle[0][0]
        
        for i in range(1, r_n):
            for j in range(i+1):
                if j - 1 < 0:
                    triangle[i][j] += triangle[i-1][j]
                elif j == i:
                    triangle[i][j] += triangle[i-1][j-1]
                else:
                    triangle[i][j] = min(triangle[i-1][j] + triangle[i][j], triangle[i-1][j-1] + triangle[i][j])
        return min(triangle[r_n - 1])
```

```
// DP b to top
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        below_row = triangle[-1] 
        n = len(triangle)
        for row in reversed(range(n - 1)):     
            curr_row = []
            for col in range(row + 1):
                smallest_below = min(below_row[col], below_row[col + 1])
                curr_row.append(triangle[row][col] + smallest_below)
            below_row = curr_row
        return below_row[0]
```

## 143 Reorder List

### Description



You are given the head of a singly linked-list. The list can be represented as:

```
L0 → L1 → … → Ln - 1 → Ln
```

_Reorder the list to be on the following form:_

```
L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …
```

You may not modify the values in the list's nodes. Only nodes themselves may be changed.

&#x20;

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/03/04/reorder1linked-list.jpg)

```
Input: head = [1,2,3,4]
Output: [1,4,2,3]
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/03/09/reorder2-linked-list.jpg)

```
Input: head = [1,2,3,4,5]
Output: [1,5,2,4,3]
```

&#x20;

**Constraints:**

* The number of nodes in the list is in the range `[1, 5 * 104]`.
* `1 <= Node.val <= 1000`

### Solution

{% embed url="https://leetcode.com/problems/reorder-list/solution" %}

```
// Some code
class Solution:
    def reorderList(self, head: ListNode) -> None:
        if not head:
            return 
        
        # find the middle of linked list [Problem 876]
        # in 1->2->3->4->5->6 find 4 
        slow = fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next 
            
        # reverse the second part of the list [Problem 206]
        # convert 1->2->3->4->5->6 into 1->2->3->4 and 6->5->4
        # reverse the second half in-place
        prev, curr = None, slow
        while curr:
            curr.next, prev, curr = prev, curr, curr.next       

        # merge two sorted linked lists [Problem 21]
        # merge 1->2->3->4 and 6->5->4 into 1->6->2->5->3->4
        first, second = head, prev
        while second.next:
            first.next, first = second, first.next
            second.next, second = first, second.next
```
