# 100-150

* [x] 101 Symmetric Tree
* [x] [103 Binary Tree Zigzag Level Order Traversal](100-150.md#103-binary-tree-zigzag-level-order-traversal)
* [x] 109 Convert Sorted List to Binary Search Tree&#x20;
* [x] 116 Populating Next Right Pointers in Each Node
* [x] 117 Populating Next Right Pointers in Each Node II
* [x] [120 Triangle](100-150.md#120-triangle)
* [x] 129 Sum Root to Leaf Numbers
* [x] 141 Linked List Cycle

## 101 Symmetric Tree E

### D



Given the `root` of a binary tree, _check whether it is a mirror of itself_ (i.e., symmetric around its center).

&#x20;

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg)

```
Input: root = [1,2,2,3,4,4,3]
Output: true
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg)

```
Input: root = [1,2,2,null,3,null,3]
Output: false
```

&#x20;

**Constraints:**

* The number of nodes in the tree is in the range `[1, 1000]`.
* `-100 <= Node.val <= 100`

### S

Recursion

```
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        return self.isMirror(root, root)
    def isMirror(self,node1: TreeNode, node2: TreeNode):
        if(node1 is None and node2 is None): return True
        if(node1 is None or node2 is None): return False
        if(node1.val != node2.val): return False
        return self.isMirror(node1.left, node2.right) and self.isMirror(node1.right, node2.left)
            
```



## 103 Binary Tree Zigzag Level Order Traversal

### Description



Given the `root` of a binary tree, return _the zigzag level order traversal of its nodes' values_. (i.e., from left to right, then right to left for the next level and alternate between).

&#x20;

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)

```
Input: root = [3,9,20,null,null,15,7]
Output: [[3],[20,9],[15,7]]
```

**Example 2:**

```
Input: root = [1]
Output: [[1]]
```

**Example 3:**

```
Input: root = []
Output: []
```

&#x20;

**Constraints:**

* The number of nodes in the tree is in the range `[0, 2000]`.
* `-100 <= Node.val <= 100`

### Solution

1. BFS

* Normal BFS is just create a deque, setting root as the first value, using while loop to iterate, each loop pop first value and push the popped node's left and right node into deque from the back.
* This time change a little bit, first add two values as init value, root node and None&#x20;
* When visiting None, means this layer has been all visited and at the same time, the queue contains all the next layer's nodes
* Then just append new None to separate  the new layer

```
// Some code
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        res = []
        level_list = deque()
        if root is None:
            return res
        
        node_queue = deque([root, None])
        reverse = False
        
        while len(node_queue) > 0:
            cur_node = node_queue.popleft()
            
            if cur_node:
                if reverse:
                    level_list.appendleft(cur_node.val)
                else:
                    level_list.append(cur_node.val)
                
                if cur_node.left:
                    node_queue.append(cur_node.left)
                if cur_node.right:
                    node_queue.append(cur_node.right)
            else:
                res.append(level_list)
                if len(node_queue) > 0:
                    node_queue.append(None)
                level_list = deque()
                reverse = not reverse
                
        return res
```

## 109 Convert Sorted List to Binary Search Tree M

### D



Given the `head` of a singly linked list where elements are **sorted in ascending order**, convert it to a height balanced BST.

For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of _every_ node never differ by more than 1.

&#x20;

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/08/17/linked.jpg)

```
Input: head = [-10,-3,0,5,9]
Output: [0,-3,9,-10,null,5]
Explanation: One possible answer is [0,-3,9,-10,null,5], which represents the shown height balanced BST.
```

**Example 2:**

```
Input: head = []
Output: []
```

&#x20;

**Constraints:**

* The number of nodes in `head` is in the range `[0, 2 * 104]`.
* `-105 <= Node.val <= 105`

### S

```
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:
        # Using slow and fast pointers to find the middle of the linked list
        def findMiddle(head):
            # Used to disconnect the left portion with middle node
            # Keep it equal to one node before slow pointer, after finding the middle node, 
            #   set the next node of prev equal to None
            prev = None 
            
            slow = head
            fast = head
            
            while fast and fast.next:
                prev = slow
                slow = slow.next
                fast = fast.next.next
            
            # If slow is head, then prev is None not prev.next is None
            if prev:
                # Normal situation, when slow is not the head node
                prev.next = None
            return slow
        
        if not head: return None
        
        # Mid linked list
        mid = findMiddle(head)
        resNode = TreeNode(mid.val)
        
        if head == mid:
            return resNode

        resNode.left = self.sortedListToBST(head)
        resNode.right = self.sortedListToBST(mid.next)
        
        return resNode
```

## 116 Populating Next Right Pointers in Each Node M

### D



You are given a **perfect binary tree** where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:

```
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to `NULL`.

Initially, all next pointers are set to `NULL`.

&#x20;

**Example 1:**

![](https://assets.leetcode.com/uploads/2019/02/14/116\_sample.png)

```
Input: root = [1,2,3,4,5,6,7]
Output: [1,#,2,3,#,4,5,6,7,#]
Explanation: Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level.
```

**Example 2:**

```
Input: root = []
Output: []
```

&#x20;

**Constraints:**

* The number of nodes in the tree is in the range `[0, 212 - 1]`.
* `-1000 <= Node.val <= 1000`

&#x20;

**Follow-up:**

* You may only use constant extra space.
* The recursive approach is fine. You may assume implicit stack space does not count as extra space for this problem.

### S

BFS

```
"""
# Definition for a Node.
class Node:
    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):
        self.val = val
        self.left = left
        self.right = right
        self.next = next
"""

class Solution:
    def connect(self, root: 'Optional[Node]') -> 'Optional[Node]':
        if not root:
            return root
        
        queue = collections.deque([root])
        
        while queue:
            level_len = len(queue)
            for i in range(level_len):
                node = queue.popleft()
                if i < level_len - 1:
                    node.next = queue[0]
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
        return root
```

Constant space&#x20;

* node.left.next = node.right
* if node.next != none
  * node.right.next = node.next.left
  * else: node.right.next = None
* Move from top to bottom
* Since we need to calculate two layers each time, so when node.left == None, we can stop loop

```
class Solution:
    def connect(self, root: 'Node') -> 'Node':
        
        if not root:
            return root
        
        # Start with the root node. There are no next pointers
        # that need to be set up on the first level
        # loop through all levels, only represent left most node of each level
        leftmost = root
        
        # Once we reach the final level, we are done
        while leftmost.left:
            
            # Iterate the "linked list" starting from the head
            # node and using the next pointers, establish the 
            # corresponding links for the next level
            # Loop through all node in the same level
            head = leftmost
            while head:
                
                # CONNECTION 1
                head.left.next = head.right
                
                # CONNECTION 2
                if head.next:
                    head.right.next = head.next.left
                
                # Progress along the list (nodes on the current level)
                head = head.next
            
            # Move onto the next level
            leftmost = leftmost.left
        
        return root 
```

## 117 Populating Next Right Pointers in Each Node II M

### D



Given a binary tree

```
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to `NULL`.

Initially, all next pointers are set to `NULL`.

&#x20;

**Example 1:**

![](https://assets.leetcode.com/uploads/2019/02/15/117\_sample.png)

```
Input: root = [1,2,3,4,5,null,7]
Output: [1,#,2,3,#,4,5,7,#]
Explanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level.
```

**Example 2:**

```
Input: root = []
Output: []
```

&#x20;

**Constraints:**

* The number of nodes in the tree is in the range `[0, 6000]`.
* `-100 <= Node.val <= 100`

&#x20;

**Follow-up:**

* You may only use constant extra space.
* The recursive approach is fine. You may assume implicit stack space does not count as extra space for this problem.

### S

1. Normal BFS
2. O(1) space complex way

```
"""
# Definition for a Node.
class Node:
    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):
        self.val = val
        self.left = left
        self.right = right
        self.next = next
"""

class Solution:
    def connect(self, root: 'Node') -> 'Node':
        if not root:
            return root
        
        queue = collections.deque();
        queue.append(root)
        
        while queue:
            queue_len = len(queue)

            for i in range(queue_len):
                node = queue.popleft()
                
                if i <= queue_len-2:
                    node.next = queue[0]
                
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
        return root
                
```

[https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/solution/](https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/solution/) second solution

* cur\_upper: the pointer used to traverse all the nodes in the same level; this level should already been linked
* prev\_down: the pointer used to traverse all the nodes in the next level, this level has not been linked
* leftmost: the left most node of the level which still linking

```
"""
# Definition for a Node.
class Node:
    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):
        self.val = val
        self.left = left
        self.right = right
        self.next = next
"""

class Solution:
    def precessChild(self, node, prev, leftmost):
        if node:
            if prev:
                prev.next = node
            else:
                leftmost = node
            prev = node
        return prev, leftmost
    def connect(self, root: 'Node') -> 'Node':
        if not root:
            return root
        
        leftmost = root
        while leftmost:
            cur_upper = leftmost
            leftmost = None
            prev_down = None
            
            while cur_upper:
                prev_down, leftmost = self.precessChild(cur_upper.left, prev_down, leftmost)
                prev_down, leftmost = self.precessChild(cur_upper.right, prev_down, leftmost)
                
                cur_upper = cur_upper.next
        return root
```

## 120 Triangle

### Description

Given a `triangle` array, return _the minimum path sum from top to bottom_.

For each step, you may move to an adjacent number of the row below. More formally, if you are on index `i` on the current row, you may move to either index `i` or index `i + 1` on the next row.

**Example 1:**

```
Input: triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
Output: 11
Explanation: The triangle looks like:
   2
  3 4
 6 5 7
4 1 8 3
The minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).
```

**Example 2:**

```
Input: triangle = [[-10]]
Output: -10
```

### Solution

```
// DP Top to buttom without space optimization
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        r_n = len(triangle)
        c_n = len(triangle[r_n - 1])
        
        if r_n == 1:
            return triangle[0][0]
        
        dp =[ [0 for _ in range(c_n)] for _ in range(r_n)]
        
        // init
        dp[0][0] = triangle[0][0]
        
        for i in range(1, r_n):
            for j in range(i+1):
                // if at the first column, will not have j-1 value
                if j - 1 < 0:
                    dp[i][j] = dp[i-1][j] + triangle[i][j]
                // if at the last column, will not have j
                elif j == i:
                    dp[i][j] = dp[i-1][j-1] + triangle[i][j]
                else:
                    dp[i][j] = min(dp[i-1][j] + triangle[i][j], dp[i-1][j-1] + triangle[i][j])
        print(dp)
        return min(dp[r_n - 1])
```

```
// DP Top-buttom With space optimi, store all in triangle
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        r_n = len(triangle)
        c_n = len(triangle[r_n - 1])
        
        if r_n == 1:
            return triangle[0][0]
        
        for i in range(1, r_n):
            for j in range(i+1):
                if j - 1 < 0:
                    triangle[i][j] += triangle[i-1][j]
                elif j == i:
                    triangle[i][j] += triangle[i-1][j-1]
                else:
                    triangle[i][j] = min(triangle[i-1][j] + triangle[i][j], triangle[i-1][j-1] + triangle[i][j])
        return min(triangle[r_n - 1])
```

```
// DP b to top
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        below_row = triangle[-1] 
        n = len(triangle)
        for row in reversed(range(n - 1)):     
            curr_row = []
            for col in range(row + 1):
                smallest_below = min(below_row[col], below_row[col + 1])
                curr_row.append(triangle[row][col] + smallest_below)
            below_row = curr_row
        return below_row[0]
```

## 143 Reorder List

### Description



You are given the head of a singly linked-list. The list can be represented as:

```
L0 → L1 → … → Ln - 1 → Ln
```

_Reorder the list to be on the following form:_

```
L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …
```

You may not modify the values in the list's nodes. Only nodes themselves may be changed.

&#x20;

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/03/04/reorder1linked-list.jpg)

```
Input: head = [1,2,3,4]
Output: [1,4,2,3]
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/03/09/reorder2-linked-list.jpg)

```
Input: head = [1,2,3,4,5]
Output: [1,5,2,4,3]
```

&#x20;

**Constraints:**

* The number of nodes in the list is in the range `[1, 5 * 104]`.
* `1 <= Node.val <= 1000`

### Solution

{% embed url="https://leetcode.com/problems/reorder-list/solution" %}

```
// Some code
class Solution:
    def reorderList(self, head: ListNode) -> None:
        if not head:
            return 
        
        # find the middle of linked list [Problem 876]
        # in 1->2->3->4->5->6 find 4 
        slow = fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next 
            
        # reverse the second part of the list [Problem 206]
        # convert 1->2->3->4->5->6 into 1->2->3->4 and 6->5->4
        # reverse the second half in-place
        prev, curr = None, slow
        while curr:
            curr.next, prev, curr = prev, curr, curr.next       

        # merge two sorted linked lists [Problem 21]
        # merge 1->2->3->4 and 6->5->4 into 1->6->2->5->3->4
        first, second = head, prev
        while second.next:
            first.next, first = second, first.next
            second.next, second = first, second.next
```

## 129 Sum Root to Leaf Numbers M

### D



You are given the `root` of a binary tree containing digits from `0` to `9` only.

Each root-to-leaf path in the tree represents a number.

* For example, the root-to-leaf path `1 -> 2 -> 3` represents the number `123`.

Return _the total sum of all root-to-leaf numbers_. Test cases are generated so that the answer will fit in a **32-bit** integer.

A **leaf** node is a node with no children.

&#x20;

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/02/19/num1tree.jpg)

```
Input: root = [1,2,3]
Output: 25
Explanation:
The root-to-leaf path 1->2 represents the number 12.
The root-to-leaf path 1->3 represents the number 13.
Therefore, sum = 12 + 13 = 25.
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/02/19/num2tree.jpg)

```
Input: root = [4,9,0,5,1]
Output: 1026
Explanation:
The root-to-leaf path 4->9->5 represents the number 495.
The root-to-leaf path 4->9->1 represents the number 491.
The root-to-leaf path 4->0 represents the number 40.
Therefore, sum = 495 + 491 + 40 = 1026.
```

&#x20;

**Constraints:**

* The number of nodes in the tree is in the range `[1, 1000]`.
* `0 <= Node.val <= 9`
* The depth of the tree will not exceed `10`.

### S

```
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def sumNumbers(self, root: Optional[TreeNode]) -> int:
        def dfs(node, curr):
            nonlocal res;
            if node:
                curr = curr*10 + node.val;
                # if it is a leaf node
                if not(node.left or node.right):
                    res += curr
                
                dfs(node.left, curr);
                dfs(node.right, curr);
        res = 0
        dfs(root, 0);
        return res;
```

## 141 Linked List Cycle E

### D

Given `head`, the head of a linked list, determine if the linked list has a cycle in it.

There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the `next` pointer. Internally, `pos` is used to denote the index of the node that tail's `next` pointer is connected to. **Note that `pos` is not passed as a parameter**.

Return `true` _if there is a cycle in the linked list_. Otherwise, return `false`.

&#x20;

**Example 1:**

![](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png)

```
Input: head = [3,2,0,-4], pos = 1
Output: true
Explanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist\_test2.png)

```
Input: head = [1,2], pos = 0
Output: true
Explanation: There is a cycle in the linked list, where the tail connects to the 0th node.
```

**Example 3:**

![](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist\_test3.png)

```
Input: head = [1], pos = -1
Output: false
Explanation: There is no cycle in the linked list.
```

&#x20;

**Constraints:**

* The number of the nodes in the list is in the range `[0, 104]`.
* `-105 <= Node.val <= 105`
* `pos` is `-1` or a **valid index** in the linked-list.

&#x20;

**Follow up:** Can you solve it using `O(1)` (i.e. constant) memory?

### S

* Two pointers
* Difficulty: how to set the while situation

```
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        if head is None:
            return False 
        
        fast, slow = head.next, head
        # Need to make sure fast.next also not None, because next fast will be fast.next.next
        while fast and fast.next:
            if fast == slow:
                return True

            fast = fast.next.next
            slow = slow.next
        return False
```
